# Reitit In Depth

1. Swagger Tools Integration
2. Coercion and Validation with Reitit
3. Defining Custom Middleware

## Swagger Tools Integration


Our routing library, Reitit, has first-class support for a very popular service API tool called Swagger. Swagger gives us plenty of benefits, like a generated JSON schema, but the most tangible at the moment is Swagger UI. Swagger UI will give us the ability to visualize and interact with our services through an auto-generated web UI.

Let’s get it set up and see what it can do for us:

### Step 1: Import swagger
```
(ns novus.router
 (:require
   ...
   [reitit.swagger :as swagger]
   [reitit.swagger-ui :as swagger-ui]))

```

### Step 2: Define swagger handler

```clj
(def swagger-docs
  ["/swagger.json"
   {:get
    {:no-doc true
     :swagger {:basePath "/"
               :info {:title "Novus Ion API Reference"
                      :description "The Novus API is organized around REST. Returns JSON, Transit (msgpack, json), or EDN  encoded responses."
                      :version "1.0.0"}}
     :handler (swagger/create-swagger-handler)}}])
```

### Step 3: Add default handler

```
(defn routes
  [env]
  (ring/ring-handler
    (ring/router
     [swagger-docs
      ["/v1"
       student/routes
       ["/courses/:id"
         {:get (fn [{{:keys [id]} :path-params}]
                 (response/response (str "Course ID:" id)))}]]]
     {:data {:muuntaja m/instance
             :middleware [muuntaja/format-middleware]}})
    (ring/routes
      (swagger-ui/create-swagger-ui-handler {:path "/"}))))
```

- The `ring/ring-handler` function accepts an optional default handler as a second argument.
- We’ve passed it a handler generated by the `ring/routes` function.
- Inside we are calling `create-swagger-ui-handler` function passing a map that contains the path value

Now if we go to http://localhost:3000, we should see swagger UI

---

## Coercion and Validation with Reitit


Now that we have Swagger UI showing up, let’s get it configured properly.

When server and client communicate, data must be encoded somehow (for example, with JSON). Since
we’re working with full-stack Clojure, it would be nice to use Clojure data structures. But what
if we wanted to have other clients? This is what Muuntaja does. Muuntaja decodes the request
body based on the Content Type header and encodes the response body using the Accept headers.

Unfortunately, many data formats, such as JSON, represent only a subset of EDN. When we’re dealing with these formats, we’ll often need to coerce from one type to another. This is handled by coercion middleware that tries to coerce the value based on the type specified in the endpoint specs. Our handlers won’t need to be concerned with this, since all they’ll see is a Clojure data structure, and their return value will be coerced into whatever response format was requested.

Middleware can be specified for a specific context. Reitit provides a suite of Ring middleware1 for accomplishing common tasks. This middleware also has richer features that leverage Reitit itself. Let’s replace middleware/wrap-formats with the middleware that Reitit provides. Although it’s more complex, it provides functionality essential to real-world web services, such as declarative coercion and valida- tion of parameters.

First, let’s require the necessary Reitit namespaces:


```clj
(ns novus.router
 (:require
   [reitit.ring :as ring]
   [ring.adapter.jetty :as jetty]
   [ring.util.response :as response]
   [clojure.repl :as repl]
   [reitit.coercion.spec :as spec-coercion]
   ;; Routes
   [novus.student.routes :as student]
   ;; Middlewares
   [muuntaja.core :as m]
   [reitit.ring.middleware.muuntaja :as muuntaja]
   [reitit.ring.middleware.parameters :as parameters]
   [reitit.ring.middleware.exception :as exception]
   [reitit.ring.coercion :as coercion]
   [reitit.ring.middleware.multipart :as multipart]
   ;; Swagger Integration
   [reitit.swagger :as swagger]
   [reitit.swagger-ui :as swagger-ui]))

```

Then let’s update the options map for our routes like so

```clj
(ns novus.router
 (:require
   ...
   ;; Custom Middleware
   [novus.middleware :as novus]
   ;; Swagger Integration
   [reitit.swagger :as swagger]
   [reitit.swagger-ui :as swagger-ui]))

(defn routes
  [env]
  (ring/ring-handler
    (ring/router
     [swagger-docs
      ["/v1"
       student/routes
       ["/courses/:id"
         {:get (fn [{{:keys [id]} :path-params}]
                 (response/response (str "Course ID:" id)))}]]]
     {:data {:env env
             :muuntaja m/instance
             :coercion spec-coercion/coercion
             :middleware [;; 1. query-params & form-params
                          parameters/parameters-middleware
                          ;; 2. content negotiation
                          muuntaja/format-negotiate-middleware
                          ;; 3. encoding response body
                          muuntaja/format-response-middleware
                          ;; 4. exception handling
                          exception/exception-middleware
                          ;; 5. decoding request body
                          muuntaja/format-request-middleware
                          ;; 6. coercing response bodys
                          coercion/coerce-response-middleware
                          ;; 7. coercing request parameters
                          coercion/coerce-request-middleware
                          ;; 8. Multi Part Params
                          multipart/multipart-middleware]}})
    (ring/routes
      (swagger-ui/create-swagger-ui-handler {:path "/"}))))
```

Notice that we added some additional attributes: `:muuntaja`and `:coercion`. This is how Reitit enriches middleware.
We can also pass custom variables like for example: `env`. This env gets used when we are defining custom middleware

## Custom Middlewares

Currently are sending mock data - lets change that. First we need a way for the handler function to access the `conn` object. We can solve this by implementing custom handler

```clj
(ns novus.middleware
  (:require [ring.util.response :as rr]))

(def wrap-env
 {:name ::env
  :description "Middleware for injecting env into request"
  ;; runs once - imporant for performance reasons
  :compile (fn [{:keys [env]} route-options]
             (fn [handler]
               (fn [request]
                 (handler (assoc request :env env)))))})


```

In our example it injects the env variable passed in the router. Next lets pass this middleware in our routes

```clj
(defn routes
  [env]
  (ring/ring-handler
    (ring/router
     [swagger-docs
      ["/v1"
       student/routes
       ["/courses/:id"
         {:get (fn [{{:keys [id]} :path-params}]
                 (response/response (str "Course ID:" id)))}]]]
     {:data {:env env
             :muuntaja m/instance
             :coercion spec-coercion/coercion
             :middleware [;; 1. query-params & form-params
                          parameters/parameters-middleware
                          ;; 2. content negotiation
                          muuntaja/format-negotiate-middleware
                          ;; 3. encoding response body
                          muuntaja/format-response-middleware
                          ;; 4. exception handling
                          exception/exception-middleware
                          ;; 5. decoding request body
                          muuntaja/format-request-middleware
                          ;; 6. coercing response bodys
                          coercion/coerce-response-middleware
                          ;; 7. coercing request parameters
                          coercion/coerce-request-middleware
                          ;; 8. Multi Part Params
                          multipart/multipart-middleware
                          ;; 9. Custom
                          novus/wrap-env]}})
    (ring/routes
      (swagger-ui/create-swagger-ui-handler {:path "/"}))))

```

With our middleware in place, lets modify the function to browse students

```clj
(ns novus.student.handlers
  (:require [ring.util.response :as rr]
            [datomic.client.api :as d]))

(defn browse
  [{{{:keys [conn]} :datomic} :env
    :as req}]
  (rr/response {:students (d/q '[:find (pull ?student [*])
                                 :where
                                 [?student :student/id]]
                             (d/db conn))}))

```


Now if we restart the server, we should see list of students reading from the database


## Coercion

Finally lets look at coercion. Lets implement an enpoint where we fetch student by ID.

First lets add the route

```clj
(ns novus.student.routes
  (:require [novus.student.handlers :as student]))

(def routes
  ["/students"
   [""
    {:get {:handler student/browse
           :responses {200 {:body {:students vector?}}}
           :summary "Fetch list of students"}}]

   ["/:studentId"
    {:get {:handler student/fetch
           :responses {201 {:body {:student map?}}}
           :parameters {:path {:studentId uuid?}}
           :summary "Fetch list of students"}}]])

```

Notice that we have added `:parameters` property. It says that the `:studentId` parameter should be a UUID

Now that we have defined the route, lets define the handler

```clj
(defn fetch
  [{{{:keys [conn]} :datomic} :env
    {{:keys [studentId]} :path} :parameters
    :as req}]
  (rr/response {:student (ffirst (d/q '[:find (pull ?student [*])
                                        :in $ ?sid
                                        :where
                                        [?student :student/id ?sid]]
                                    (d/db conn)
                                    studentId))}))
```

Notice that our parameters are automatically coerced from string to UUID due to the fact that we have specified in parameters property in the routes.

Now if we restart the server and try to fetch a student with valid ID. we should get a map.


Now with that change in place lets git commit to git and deploy our app
