The complete How to Code course consists of 2 parts, each of which is 6 weeks long. Each week consists of 1 or 2 modules, and those modules all have a similar structure, comprised of:

An overview describing the module learning goals and summarizing the work required to complete the module.
A number of blended topic lectures, consisting of video interspersed with questions for you to answer.
A set of problems that will let you practice the new design techniques before the quiz.
Several discussion questions. These questions help organize the general discussion forums by creating a section for each module. The discussion forums are a great resource to see what other students had to say about the material you are working on. The course staff will also be active in the disussion forums.
A module quiz. The module quiz is a self-assessed design problem.
A module wrap up.
The following chart provides an overview of the course topics:

## Modules

1. Clojure
- Learn to program with the core of the programming language used throughout the course.

2. How to Design Functions (HtDF) Recipe
- Learn to use the HtDF recipe to design functions that consume simple primitive data.
Application:
  - Company: Duolingo
  - Feature: Quiz

3. How to Design Data (HtDD) Recipe
4. Compound Data
Learn to use the HtDD recipe to design data definitions for atomic data.

5. Self-Reference
- Learn how to use well-formed self-referential data definitions to represent arbitrary sized data.
6. Reference
- Learn to predict and identify the correspondence between references in a data definition and helper function calls in functions that operate on the data.

7. Naturals
- Design an alternate data definition for the natural numbers, and learn to write functions using this new data definition.

8. Helpers
- Learn a set of rules for designing functions with helper functions.

9. Binary Search Trees
Design a data definition for Binary Search Trees, and learn to write functions operating on BSTs.

Part 2 of the course, Complex Data covers arbitrary-arity trees, functions consuming two complex types, the use of local expressions to improve program clarity and/or performance, abstraction, generative recursion, search, accumulators, and graphs.
